package org.grits.toolbox.tools.databasebot.process;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;

import org.apache.log4j.Logger;
import org.eurocarbdb.MolecularFramework.io.SugarImporterException;
import org.eurocarbdb.MolecularFramework.io.GlycoCT.SugarExporterGlycoCTCondensed;
import org.eurocarbdb.MolecularFramework.io.GlycoCT.SugarImporterGlycoCTCondensed;
import org.eurocarbdb.MolecularFramework.sugar.Sugar;
import org.eurocarbdb.MolecularFramework.util.visitor.GlycoVisitorException;
import org.eurocarbdb.application.glycanbuilder.Glycan;
import org.eurocarbdb.application.glycanbuilder.IonCloud;
import org.eurocarbdb.application.glycanbuilder.MassOptions;
import org.eurocarbdb.application.glycanbuilder.ResidueDictionary;
import org.grits.toolbox.tools.databasebot.dialog.process.ProgressDialogThread;
import org.grits.toolbox.tools.databasebot.excel.ReportGenerator;
import org.grits.toolbox.tools.databasebot.om.DatabaseBotSettings;
import org.grits.toolbox.tools.databasebot.om.GlycanInformation;
import org.grits.toolbox.tools.databasebot.utils.FileUtils;
import org.grits.toolbox.tools.databasebot.utils.GlycoVisitorComposition;
import org.grits.toolbox.tools.databasebot.utils.GlycoVisitorTopology;
import org.grits.toolbox.util.structure.glycan.database.GlycanDatabase;
import org.grits.toolbox.util.structure.glycan.database.GlycanStructure;
import org.grits.toolbox.util.structure.glycan.filter.GlycanFilterException;
import org.grits.toolbox.util.structure.glycan.filter.GlycanFilterOperator;
import org.grits.toolbox.util.structure.glycan.filter.om.Filter;

/**
 * Utility class that does create a set of structures based on specified
 * settings: (A) should a new database be created or one from an existing file;
 * (B) should new structures be added? If new structures are added these can
 * come from GWS files or from the Qrator web services.
 *
 * @author rene
 *
 */
public class DatabaseGenerator extends ProgressDialogThread
{
    private static final Logger logger = Logger.getLogger(DatabaseGenerator.class);

    /** Database settings generated by the wizard */
    private DatabaseBotSettings m_settings = null;
    /** New database */
    private GlycanDatabase m_database = null;
    /** Counter used to generate new IDs */
    private Integer m_idCounter = 0;
    /** List of all the glycans (filtered and unfiltered) */
    private List<GlycanInformation> m_glycans = new ArrayList<>();
    private MassOptions m_massOptions = null;
    private HashMap<String, String> m_hashGlycoCT = new HashMap<>();

    public DatabaseGenerator()
    {
        this.m_massOptions = new MassOptions();
        this.m_massOptions.setDerivatization(MassOptions.NO_DERIVATIZATION);
        this.m_massOptions.setIsotope(MassOptions.ISOTOPE_MONO);
        this.m_massOptions.setReducingEndType(ResidueDictionary.findResidueType("freeEnd"));
        this.m_massOptions.ION_CLOUD = new IonCloud();
        this.m_massOptions.NEUTRAL_EXCHANGES = new IonCloud();
    }

    public DatabaseBotSettings getSettings()
    {
        return this.m_settings;
    }

    public void setSettings(DatabaseBotSettings a_settings)
    {
        this.m_settings = a_settings;
    }

    /**
     * Method that starts the database generation based on the settings
     */
    @Override
    public boolean threadStart() throws Exception
    {
        // initialize database
        this.m_progressReporter.setProcessMessageLabel("Task 1 of 7: Initialize database ...");
        try
        {
            this.initializeDatabase();
        }
        catch (JAXBException e)
        {
            this.m_progressReporter.setDescriptionText(
                    "There was an error opening " + this.m_settings.getExtendDatabaseFile() + "\n" + e.getMessage());
            logger.error("Error opening database file: " + this.m_settings.getExtendDatabaseFile(), e);
            return false;
        }
        catch (CancelProcessException e)
        {
            return false;
        }
        catch (Exception e)
        {
            this.m_progressReporter.setDescriptionText(
                    "Error loading structures from " + this.m_settings.getExtendDatabaseFile() + "\n" + e.getMessage());
            logger.error("Error loading structures from database file: " + this.m_settings.getExtendDatabaseFile(), e);
            return false;
        }
        // add new structures
        this.m_progressReporter.setProcessMessageLabel("Task 2 of 7: Add new structures");
        try
        {
            this.addNewStructures();
        }
        catch (CancelProcessException e)
        {
            return false;
        }
        // filter the structures
        this.m_progressReporter.setProcessMessageLabel("Task 3 of 7: Filter structures");
        try
        {
            // filter all the glycans and set if they passed the filter or not
            if (this.m_settings.getFilterSetting() != null)
            {
                Filter t_filter = this.m_settings.getFilterSetting().getFilter();
                this.m_progressReporter.setMax(this.m_glycans.size());
                Integer t_counter = 0;
                String t_messagePart = " of " + Integer.toString(this.m_glycans.size()) + " glycans";
                for (GlycanInformation t_glycan : this.m_glycans)
                {
                    t_counter++;
                    if (this.m_canceled)
                    {
                        return false;
                    }
                    this.m_progressReporter.updateProgresBar(t_counter.toString() + t_messagePart);
                    // apply filter to each structure
                    if (GlycanFilterOperator.evaluate(t_glycan.getSugar(), t_filter))
                    {
                        t_glycan.setPassFilter(Boolean.TRUE);
                    }
                    else
                    {
                        t_glycan.setPassFilter(Boolean.FALSE);
                    }
                }
            }
        }
        catch (GlycanFilterException e)
        {
            this.m_progressReporter.setDescriptionText("Error when filtering structures: " + e.getMessage());
            logger.error("Error when filtering structures", e);
            return false;
        }
        List<GlycanInformation> t_listToProcess = this.m_glycans;
        // should a topology database be created?
        this.m_progressReporter.setProcessMessageLabel("Task 4 of 7: Topology database generation");
        try
        {
            if (this.m_settings.getTopologyDatabase())
            {
                this.m_progressReporter.setMax(this.m_glycans.size());
                t_listToProcess = this.generateTopologyStructures();
            }
            if (this.m_canceled)
            {
                return false;
            }
        }
        catch (Exception e)
        {
            this.m_progressReporter.setDescriptionText("Error when generating topology database: " + e.getMessage());
            logger.error("Error when generating topology database", e);
            return false;
        }
        // set the IDs for all structures
        this.m_progressReporter.setProcessMessageLabel("Task 5 of 7: Generating database IDs");
        this.m_progressReporter.setMax(100);
        this.generateIds(t_listToProcess);
        if (this.m_canceled)
        {
            return false;
        }
        // no we copy the structures to the database
        this.m_progressReporter.setProcessMessageLabel("Task 6 of 7: Save database file");
        this.m_progressReporter.setMax(100);
        this.addStructuresToDatabase(t_listToProcess);
        try
        {
            this.saveDatabase();
            if (this.m_canceled)
            {
                try
                {
                    Files.delete(Paths.get(this.m_settings.getFilename()));
                }
                catch (IOException e)
                {
                    logger.error("Unable to delete database file: " + this.m_settings.getFilename(), e);
                }
                return false;
            }
        }
        catch (JAXBException e)
        {
            this.m_progressReporter.setDescriptionText("Error when writting the new database: " + e.getMessage());
            logger.error("Error when writting the new database", e);
            return false;
        }
        // generate Report file
        this.m_progressReporter.setProcessMessageLabel("Task 7 of 7: Generating report file");
        this.m_progressReporter.setMax(100);
        try
        {
            if (this.m_settings.getReportFile() != null)
            {
                this.generateReport(t_listToProcess);
            }
            if (this.m_canceled)
            {
                try
                {
                    Files.delete(Paths.get(this.m_settings.getFilename()));
                }
                catch (IOException e)
                {
                    logger.error("Unable to delete database file: " + this.m_settings.getFilename(), e);
                }
                try
                {
                    Files.delete(Paths.get(this.m_settings.getReportFile()));
                }
                catch (IOException e)
                {
                    logger.error("Unable to delete database file: " + this.m_settings.getReportFile(), e);
                }
                return false;
            }
        }
        catch (Exception e)
        {
            this.m_progressReporter.setDescriptionText("Error when generating the Excel report: " + e.getMessage()
                    + "\nBut the database file was created anyway!");
            logger.error("Error when generating the Excel report", e);
            return false;
        }
        return true;
    }

    private void addStructuresToDatabase(List<GlycanInformation> a_listToProcess)
    {
        // copy all glycans from the information list that have passed the
        // filter into GlycanStructure objects and add them to the database
        List<GlycanStructure> t_glycans = new ArrayList<>();
        for (GlycanInformation t_glycanInformation : a_listToProcess)
        {
            if (t_glycanInformation.getPassFilter())
            {
                GlycanStructure t_structure = new GlycanStructure();
                t_structure.setId(t_glycanInformation.getId());
                t_structure.setGWBSequence(t_glycanInformation.getGwb());
                t_structure.setGlytoucanid(t_glycanInformation.getGlytoucanId());
                t_glycans.add(t_structure);
            }
        }
        this.m_database.setStructures(t_glycans);
        // set the correct structure count value and save database file
        this.m_database.setStructureCount(t_glycans.size());
    }

    private void generateIds(List<GlycanInformation> a_listToProcess)
    {
        if (this.m_settings.getOverwriteIds())
        {
            HashMap<String, Boolean> t_usedIDs = new HashMap<>();
            // generated IDs for all structures
            for (GlycanInformation t_glycanStructure : a_listToProcess)
            {
                if (t_glycanStructure.getPassFilter())
                {
                    // find the next available ID and set it to the glycan
                    String t_id = this.nextId(t_usedIDs);
                    t_glycanStructure.setId(t_id);
                    t_usedIDs.put(t_id, Boolean.FALSE);
                }
            }
        }
        else
        {
            // find all existing IDs and put them in a HashMap
            HashMap<String, Boolean> t_usedIDs = new HashMap<>();
            for (GlycanInformation t_glycanStructure : a_listToProcess)
            {
                if (t_glycanStructure.getPassFilter())
                {
                    t_usedIDs.put(t_glycanStructure.getId(), Boolean.TRUE);
                }
            }
            // generated IDs for all structures
            for (GlycanInformation t_glycanStructure : a_listToProcess)
            {
                if (t_glycanStructure.getPassFilter())
                {
                    // only for glycans that do not have an ID yet
                    if (t_glycanStructure.getId() == null)
                    {
                        // find the next available ID and set it to the glycan
                        String t_id = this.nextId(t_usedIDs);
                        t_glycanStructure.setId(t_id);
                        t_usedIDs.put(t_id, Boolean.FALSE);
                    }
                }
            }
        }
    }

    private void saveDatabase() throws JAXBException
    {
        // create JAXB context and marshaller
        JAXBContext t_context = JAXBContext.newInstance(GlycanDatabase.class);
        Marshaller t_marshaller = t_context.createMarshaller();
        t_context = JAXBContext.newInstance(GlycanDatabase.class);
        t_marshaller = t_context.createMarshaller();
        // output pretty printed
        t_marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
        // write the file
        t_marshaller.marshal(this.m_database, new File(this.m_settings.getFilename()));
    }

    /**
     * Add new structures to the database either from Qrator or from GWS file or
     * none of them.
     *
     * @throws CancelProcessException
     *
     */
    private void addNewStructures() throws CancelProcessException
    {
        // if there are GWS files specified by the user
        if (this.m_settings.getGwsFiles().size() != 0)
        {
            this.m_progressReporter.setMax(this.m_settings.getGwsFiles().size());
            // go over the GWS files
            for (String t_fileName : this.m_settings.getGwsFiles())
            {
                File t_file = new File(t_fileName);
                this.m_progressReporter.updateProgresBar("Loading: " + t_file.getName());
                try
                {
                    // read the files and split the different sequences
                    String t_gwsMulti = FileUtils.readFile(t_fileName);
                    String[] t_gwsList = t_gwsMulti.split(";");
                    for (String t_gws : t_gwsList)
                    {
                        if (this.m_canceled)
                        {
                            throw new CancelProcessException();
                        }
                        // for each sequence in the file create GWB glycan
                        // object
                        Glycan t_glycan = Glycan.fromString(t_gws);
                        if (t_glycan == null)
                        {
                            this.m_progressReporter.setDescriptionText(
                                    "Warning: Unable to load sequence from GWB file, the sequence will be ignored: "
                                            + t_gws);
                            logger.info("Invalid GWS sequence in file (" + t_fileName + "): " + t_gws);
                        }
                        else
                        {
                            // we have a glycan object, try to generate the mass
                            // and test if we can convert it GlycoCT
                            t_glycan.computeMass();
                            if (this.testGlycoCT(t_glycan))
                            {
                                // good structure, add to database
                                GlycanStructure t_structure = new GlycanStructure();
                                t_structure.setGWBSequence(t_glycan.toString());
                                GlycanInformation t_info = this.createGlycanGWS(t_glycan.toString());
                                if (this.m_hashGlycoCT.get(t_info.getGlycoCT()) == null)
                                {
                                    this.m_hashGlycoCT.put(t_info.getGlycoCT(), "New Structure");
                                    this.m_glycans.add(t_info);
                                }
                                else
                                {
                                    logger.warn("Trying to add duplicate GWS sequence to database: " + t_info.getGwb());
                                    this.m_progressReporter.setDescriptionText(
                                            "Warning: Trying to add duplicated GWS sequence to database "
                                                    + t_info.getGwb());
                                }
                            }
                            else
                            {
                                this.m_progressReporter.setDescriptionText(
                                        "Warning: Unable to process sequence from GWB file, the sequence will be ignored: "
                                                + t_gws);
                                logger.warn(
                                        "Unable to process GWS sequence and generate GlycoCT information: " + t_gws);
                            }
                        }
                    }
                }
                catch (CancelProcessException e)
                {
                    throw e;
                }
                catch (Exception e)
                {
                    this.m_progressReporter.setDescriptionText("Warning: Error when loading GWB file: " + t_fileName
                            + " - this file will be ignored\n\t" + e.getMessage());
                    logger.debug("Problem loading GWS file", e);
                }
            }
        }
    }

    /**
     * Generates the next possible ID. Uses the prefix given by the user and a
     * number. It also checks if the ID is already present (e.g. if another
     * database with the same prefix is loaded as the seed)
     *
     * @param a_usedIDs
     *            List of all IDs that have been used so far
     *
     * @return next available ID
     */
    private String nextId(HashMap<String, Boolean> a_usedIDs)
    {
        String t_newID = null;
        boolean t_foundId = false;
        while (!t_foundId)
        {
            // increment counter and see if the ID with this prefix already
            // exists
            this.m_idCounter++;
            t_newID = this.m_settings.getIdPrefix() + this.m_idCounter.toString() + this.m_settings.getIdPostfix();
            if (a_usedIDs.get(t_newID) == null)
            {
                // does not exist, thats the next ID
                t_foundId = true;
            }
        }
        return t_newID;
    }

    /**
     * Method that tests if a Glycan object (GWS) can be translated to GlycoCT
     * and back. Making sure extra data can be calculated and not substituents
     * are lost in the translation
     *
     * @param a_glycan
     *            Glycan object that needs to be tested
     * @return true if the process was successful, false if the old GWS string
     *         and the new GWS do not match
     * @throws SugarImporterException
     * @throws GlycoVisitorException
     */
    private boolean testGlycoCT(Glycan a_glycan)
    {
        return true;
        // TODO
        // try
        // {
        // String t_gwsStart = a_glycan.toStringOrdered();
        // // get sugar object for GWS
        // Sugar t_sugar = this.gwsToSugar(a_glycan);
        // // write GlycoCT again
        // SugarExporterGlycoCTCondensed t_exporterGlycoCTCondensed = new
        // SugarExporterGlycoCTCondensed();
        // t_exporterGlycoCTCondensed.start(t_sugar);
        // String t_glycoCTrecode = t_exporterGlycoCTCondensed.getHashCode();
        // // create new glycan object
        // Glycan t_glycanRecode = Glycan.fromGlycoCTCondensed(t_glycoCTrecode);
        // t_glycanRecode.setMassOptions(a_glycan.getMassOptions());
        // // check with old Glycan object
        // if (t_glycanRecode.toStringOrdered().equals(t_gwsStart))
        // {
        // return true;
        // }
        // else
        // {
        // return false;
        // }
        // }
        // catch (Exception e)
        // {
        // logger.error("Exception when recoding glycan (" + a_glycan.toString()
        // + ")", e);
        // return false;
        // }
        // }
        //
        // private Sugar gwsToSugar(Glycan a_gws) throws SugarImporterException
        // {
        // // get GlycoCT
        // String t_glycoCT = a_gws.toGlycoCTCondensed();
        // // read GlycoCT
        // SugarImporterGlycoCTCondensed t_importerGlycoCTCondensed = new
        // SugarImporterGlycoCTCondensed();
        // Sugar t_sugar = t_importerGlycoCTCondensed.parse(t_glycoCT);
        // return t_sugar;
    }

    /**
     * Initialize the database either by creating a new database or loading from
     * file
     *
     * @throws JAXBException
     *             If its not possible to load from file
     * @throws GlycoVisitorException
     * @throws SugarImporterException
     * @throws CancelProcessException
     */
    private void initializeDatabase()
            throws JAXBException, SugarImporterException, GlycoVisitorException, CancelProcessException
    {
        // if we start from an existing database we have to load the structures
        if (this.m_settings.getExtendDatabaseFile() != null)
        {
            // create context and unmarshaller
            JAXBContext t_jaxbContext = JAXBContext.newInstance(GlycanDatabase.class);
            Unmarshaller t_jaxbUnmarshaller = t_jaxbContext.createUnmarshaller();
            // create file and load database from file
            File t_file = new File(this.m_settings.getExtendDatabaseFile());
            GlycanDatabase t_database = (GlycanDatabase) t_jaxbUnmarshaller.unmarshal(t_file);
            this.m_progressReporter.setMax(t_database.getStructures().size());
            Integer t_counter = 0;
            String t_messagePart = " of " + Integer.toString(t_database.getStructures().size()) + " glycans";
            for (GlycanStructure t_glycan : t_database.getStructures())
            {
                t_counter++;
                this.m_progressReporter.updateProgresBar(t_counter.toString() + t_messagePart);
                if (this.m_canceled)
                {
                    throw new CancelProcessException();
                }
                GlycanInformation t_info = this.createGlycanGWS(t_glycan.getId(), t_glycan.getGWBSequence());
                t_info.setGlytoucanId(t_glycan.getGlytoucanid());
                if (this.m_hashGlycoCT.get(t_info.getGlycoCT()) == null)
                {
                    this.m_hashGlycoCT.put(t_info.getGlycoCT(), t_info.getId());
                    this.m_glycans.add(t_info);
                }
                else
                {
                    logger.warn("There was a duplicated GlycoCT structure in database "
                            + this.m_hashGlycoCT.get(t_info.getGlycoCT()) + " and " + t_info.getId());
                    this.m_progressReporter
                            .setDescriptionText("Warning: There was a duplicated GlycoCT structure in database "
                                    + this.m_hashGlycoCT.get(t_info.getGlycoCT()) + " and " + t_info.getId()
                                    + ". The latter will be ignored.");
                }
            }
        }
        // copy the information from the user into the new database metadata
        this.m_database = new GlycanDatabase();
        this.m_database.setName(this.m_settings.getName());
        this.m_database.setDescription(this.m_settings.getDescription());
        this.m_database.setVersion(this.m_settings.getVersion());
    }

    private GlycanInformation createGlycanGWS(String a_gwbSequence) throws SugarImporterException, GlycoVisitorException
    {
        return this.createGlycanGWS(null, a_gwbSequence);
    }

    private List<GlycanInformation> generateTopologyStructures() throws SugarImporterException, GlycoVisitorException
    {
        // prepare the hashmap to find duplicated sequences and the new glycan
        // list
        HashMap<String, GlycanInformation> t_topologies = new HashMap<>();
        List<GlycanInformation> t_topologyList = new ArrayList<>();
        Integer t_counter = 0;
        String t_messagePart = " of " + Integer.toString(this.m_glycans.size()) + " sequences";
        // for all the structures in the existing list
        for (GlycanInformation t_glycanInformation : this.m_glycans)
        {
            t_counter++;
            this.m_progressReporter.updateProgresBar(t_counter.toString() + t_messagePart);
            // create a copy of the sugar object
            Sugar t_sugar = this.cloneSugar(t_glycanInformation.getSugar());
            // generate a topology sugar and export to GlycoCT
            GlycoVisitorTopology t_visitor = new GlycoVisitorTopology();
            t_visitor.start(t_sugar);
            SugarExporterGlycoCTCondensed t_exporter = new SugarExporterGlycoCTCondensed();
            t_exporter.start(t_sugar);
            String t_newSequence = t_exporter.getHashCode();
            // check if the sequence was encountered before, if not add the new
            // list
            GlycanInformation t_glycanInfoFromHash = t_topologies.get(t_newSequence);
            if (t_glycanInfoFromHash == null)
            {
                GlycanInformation t_newGlycanInfo = this.createGlycanInformation(t_newSequence);
                // copy the filter state from the original sugar
                t_newGlycanInfo.setPassFilter(t_glycanInformation.getPassFilter());
                t_newGlycanInfo.addTopoglogyOrigin(t_glycanInformation);
                t_topologyList.add(t_newGlycanInfo);
                t_topologies.put(t_newSequence, t_newGlycanInfo);
            }
            else
            {
                // store that this sequence resulted in the same topology
                t_glycanInfoFromHash.addTopoglogyOrigin(t_glycanInformation);
                if (!t_glycanInfoFromHash.getPassFilter())
                {
                    t_glycanInfoFromHash.setPassFilter(t_glycanInformation.getPassFilter());
                }
            }
        }
        return t_topologyList;
    }

    /**
     * Create a copy of a sugar object. The copy and the original do not share
     * any objects. This is archived by exporting the sugar to GlycoCT and
     * re-importing the GlycoCT and creating a new sugar object.
     *
     * @param a_sugar
     *            Sugar to be copied
     * @return Copy of the sugar object
     * @throws SugarImporterException
     *             Parsing error when GlycoCT is imported
     * @throws GlycoVisitorException
     *             Error when exporting the Sugar to GlycoCT
     */
    private Sugar cloneSugar(Sugar a_sugar) throws SugarImporterException, GlycoVisitorException
    {
        // export the sugar to GlycoCT
        SugarExporterGlycoCTCondensed t_exporter = new SugarExporterGlycoCTCondensed();
        t_exporter.start(a_sugar);
        String t_sequence = t_exporter.getHashCode();
        // re-import the GlycoCT sequence and create a new sugar object
        SugarImporterGlycoCTCondensed t_importer = new SugarImporterGlycoCTCondensed();
        Sugar t_sugar = t_importer.parse(t_sequence);
        return t_sugar;
    }

    private GlycanInformation createGlycanInformation(String a_glycoCT)
            throws SugarImporterException, GlycoVisitorException
    {
        SugarImporterGlycoCTCondensed t_importer = new SugarImporterGlycoCTCondensed();
        Sugar t_sugar = t_importer.parse(a_glycoCT);
        Glycan t_glycan = Glycan.fromGlycoCTCondensed(a_glycoCT);
        return this.createGlycanInformation(t_sugar, t_glycan);
    }

    private GlycanInformation createGlycanInformation(Sugar a_sugar, Glycan a_glycan) throws GlycoVisitorException
    {
        // get GlycoCT
        SugarExporterGlycoCTCondensed t_exporter = new SugarExporterGlycoCTCondensed();
        t_exporter.start(a_sugar);
        String t_glycoCT = t_exporter.getHashCode();
        // calculate masses
        double t_mass = this.getMass(a_glycan, MassOptions.NO_DERIVATIZATION);
        double t_massPme = this.getMass(a_glycan, MassOptions.PERMETHYLATED);
        // calculate composition
        GlycoVisitorComposition t_visitor = new GlycoVisitorComposition();
        t_visitor.start(a_sugar);
        HashMap<String, Integer> t_composition = t_visitor.getComposition();
        String t_compositionName = this.getCompositionString(t_composition);
        // create the object and fill it
        GlycanInformation t_info = new GlycanInformation();
        t_info.setComposition(t_composition);
        t_info.setMass(t_mass);
        t_info.setMassPme(t_massPme);
        t_info.setCompositionName(t_compositionName);
        t_info.setGwb(a_glycan.toString());
        t_info.setGlycoCT(t_glycoCT);
        t_info.setSugar(a_sugar);
        t_info.setGlycan(a_glycan);
        return t_info;
    }

    private GlycanInformation createGlycanGWS(String a_id, String a_gwbSequence)
            throws SugarImporterException, GlycoVisitorException
    {
        Glycan t_glycan = Glycan.fromString(a_gwbSequence);
        String t_glycoCT = t_glycan.toGlycoCTCondensed();
        SugarImporterGlycoCTCondensed t_importer = new SugarImporterGlycoCTCondensed();
        Sugar t_sugar = t_importer.parse(t_glycoCT);
        GlycanInformation t_info = this.createGlycanInformation(t_sugar, t_glycan);
        t_info.setId(a_id);
        return t_info;
    }

    private double getMass(Glycan a_glycan, String a_derivatization)
    {
        this.m_massOptions.setDerivatization(a_derivatization);
        a_glycan.setMassOptions(this.m_massOptions);
        return a_glycan.computeMass();
    }

    private String getCompositionString(HashMap<String, Integer> a_composition)
    {
        String t_result = "";
        List<String> t_list = new ArrayList<>();
        for (String t_string : a_composition.keySet())
        {
            t_list.add(t_string);
        }
        Collections.sort(t_list);
        for (String t_string : t_list)
        {
            t_result += this.formatComposition(t_string) + a_composition.get(t_string).toString() + " ";
        }
        return t_result;
    }

    private String formatComposition(String a_string)
    {
        String t_string = a_string;
        if (a_string.equals("dnonA-ulop-n-acetyl"))
        {
            t_string = "NeuAc";
        }
        else if (a_string.equals("hex-n-acetyl"))
        {
            t_string = "HexNAc";
        }
        else if (a_string.equals("dnonA-ulop"))
        {
            t_string = "KDN";
        }
        else if (a_string.equals("dnonA-ulop-n-glycolyl"))
        {
            t_string = "NeuGc";
        }
        else if (a_string.equals("dhex"))
        {
            t_string = "dHex";
        }
        else if (a_string.equals("hex"))
        {
            t_string = "Hex";
        }
        else
        {
            // System.out.println(a_string);
        }
        return t_string;
    }

    private void generateReport(List<GlycanInformation> a_glycans)
            throws SugarImporterException, GlycoVisitorException, IOException
    {
        ReportGenerator t_excel = new ReportGenerator();
        t_excel.setImageScalingFactor(this.m_settings.getImageScalingFactor());
        if (this.m_settings.getTopologyDatabase())
        {
            t_excel.writeTopology(this.m_settings.getReportFile(), a_glycans, this.m_glycans);
        }
        else
        {
            t_excel.write(this.m_settings.getReportFile(), a_glycans);
        }
    }
}
